import json
import os
import subprocess
import tempfile
from concurrent.futures import Future
from pathlib import Path

from avala_shared.logs import logger
from avala_shared.util import colorize, did_you_mean

from .api import APIClient
from .models import (
    ExploitConfig,
    ServiceScopedAttackData,
    TargetingStrategy,
    UnscopedAttackData,
)

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"


class Exploit:
    def __init__(
        self,
        config: ExploitConfig,
        client: APIClient,
        attack_data: UnscopedAttackData | None = None,
        attack_data_future: Future[UnscopedAttackData] | None = None,
    ):
        """
        Runnable configured Exploit.

        :param config: Exploit configuration provided by the user through `@exploit` decorator.
        :type config: ExploitConfig
        :param client: Client responsible for communication with the Avala server API and keeping configuration for the game and scheduling.
        :type client: APIClient
        :param attack_data: `UnscopedAttackData` fetched immediately from the Avala server, used for running exploits in drafts mode.
        :type attack_data: UnscopedAttackData | Future[UnscopedAttackData]
        :param attack_data_future: Future object that will return `UnscopedAttackData` when the Avala server responds, used for running exploits.
        :type attack_data_future: Future[UnscopedAttackData] | None
        :raises ValueError: Exploit configuration is not valid.
        """
        self.client = client

        self.service = config.service
        self.alias = config.alias
        self.target_hosts = config.target_hosts
        self.target_strategy = config.target_strategy
        self.tick_scope = config.tick_scope
        self.skip = config.skip or [*client.game.team_ip, *client.game.nop_team_ip]
        self.prepare = config.prepare
        self.cleanup = config.cleanup
        self.command = config.command
        self.env = config.env
        self.delay = config.delay
        self.batching = config.batching
        self.workers = config.workers
        self.timeout = config.timeout

        self.func_name = config.meta.name
        self.module = config.meta.module
        self.directory = config.meta.directory
        self.func_takes_flag_ids = config.meta.arg_count == 2

        self.attack_data = attack_data
        self.attack_data_future = attack_data_future
        self.service_attack_data: ServiceScopedAttackData
        self.exported_service_attack_data_path: str
        self.is_draft = config.is_draft

        self.batched_target_hosts: list[list[str]] = []

        if (
            not self.func_takes_flag_ids
            and self.target_strategy == TargetingStrategy.AUTO
        ):
            raise ValueError(
                f"Cannot use AUTO targeting strategy without flag IDs. Either specify targets manually or add `flag_ids` argument to function <b>{self.func_name}</>."
            )

    def setup(self) -> bool:
        """
        Prepares the exploit by computing attack data, targets, and batching.

        :return: Weather the setup is successful.
        :rtype: boolean
        """
        if self.func_takes_flag_ids:
            if self.attack_data:
                attack_data = self.attack_data
            elif self.attack_data_future:
                attack_data = self.attack_data_future.result()
            else:
                logger.error(
                    "⚠️ Either attack data or attack data future object is required for exploit <b>{alias}</> but none of them is provided.",
                    alias=colorize(self.alias),
                )
                return False

            try:
                self.service_attack_data = attack_data / self.service
            except KeyError:
                suggestion = did_you_mean(self.service, attack_data.get_services())

                logger.error(
                    "⚠️ Service <i>{service}</> specified for <b>{alias}</> not found in attack data. {suggestion}",
                    service=self.service,
                    alias=colorize(self.alias),
                    suggestion=suggestion,
                )
                return False

            self.exported_service_attack_data_path = self._export_service_attack_data()

            if self.target_strategy == TargetingStrategy.AUTO:
                self.target_hosts = self.service_attack_data.get_targets()

        if self.target_strategy == TargetingStrategy.OWN_TEAM:
            self.target_hosts = self.client.game.team_ip
        elif self.target_strategy == TargetingStrategy.NOP_TEAM:
            self.target_hosts = self.client.game.nop_team_ip
        elif self.target_strategy is None and self.target_hosts is not None:
            self.target_hosts = [t for t in self.target_hosts if t not in self.skip]
        else:
            logger.error(
                "⚠️ Either targets or targeting strategy must be provided for exploit <b>{alias}</>. None provided. Available strategies: {strategies}",
                strategy=self.target_strategy,
                alias=colorize(self.alias),
                strategies=[s.value for s in TargetingStrategy],
            )
            return False

        if self.batching:
            if self.batching.size:
                self.batched_target_hosts = self._batch_target_hosts_by_size()
            elif self.batching.count:
                self.batched_target_hosts = self._batch_target_hosts_by_count()

        return True

    def run(self, batch_idx: int | None = None):
        """
        Runs the exploit by running appropriate executor in a separate subprocess.

        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        """
        targets = (
            self.batched_target_hosts[batch_idx]
            if self.batching and batch_idx is not None
            else self.target_hosts
        )

        if not targets:
            logger.warning(
                "⏩ Skipped {alias} due to no targets specified.",
                alias=colorize(self.alias),
            )
            return

        if self.command:
            # For shell exploits: To prevent zombie processes after a timeout,
            # the exploit processes must be terminated within the executor. Exit
            # codes are used to differentiate between timeouts and other errors.

            cmd = self._build_shell_executor_command(targets, batch_idx)
            try:
                subprocess.run(
                    cmd,
                    text=True,
                    env={**self.env, **os.environ},
                    check=True,
                )
            except subprocess.CalledProcessError as e:
                if e.returncode == 2:
                    logger.error(
                        "Exploit <b>{alias}</> exited because it has timed out.",
                        alias=colorize(self.alias),
                    )
                else:
                    logger.error(
                        "Exploit <b>{alias}</> exited with non-zero exit code {code}.",
                        alias=colorize(self.alias),
                        code=e.returncode,
                    )
        else:
            # For Python exploits: Timeouts are managed by terminating the executor
            # process itself, which will terminate all exploit theads. This is done
            # via the timeout parameter in subprocess.run.

            cmd = self._build_python_executor_command(targets, batch_idx)
            try:
                subprocess.run(
                    cmd,
                    text=True,
                    env={**self.env, **os.environ},
                    timeout=self.timeout,
                )
            except subprocess.TimeoutExpired:
                logger.error(
                    "Exploit <b>{alias}</> exited because it has timed out.",
                    alias=colorize(self.alias),
                )

        if self.func_takes_flag_ids and self._is_last_batch(batch_idx):
            try:
                os.unlink(self.exported_service_attack_data_path)
            except FileNotFoundError:
                pass

    def _build_python_executor_command(
        self,
        targets: list[str],
        batch_idx: int | None = None,
    ) -> list[str]:
        """
        Builds a command to run the exploit using the Python executor.

        :param targets: List of IP addresses or hostnames of the targets.
        :type targets: list[str]
        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        :return: Command to run.
        :rtype: list[str]
        """
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--func-name",
            self.func_name,
            "--module",
            self.module,
            "--directory",
            self.directory,
            "--tick-scope",
            self.tick_scope.value,
            "--workers",
            self.workers,
        ]

        if self.func_takes_flag_ids:
            cmd.extend(["--attack-data-file", self.exported_service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        if self.is_draft:
            cmd.append("--draft")

        return [str(c) for c in cmd if c is not None]

    def _build_shell_executor_command(
        self,
        targets: list[str],
        batch_idx: int | None = None,
    ):
        """
        Builds a command to run the exploit using the shell executor.

        :param targets: List of IP addresses or hostnames of the targets.
        :type targets: list[str]
        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        :return: Command to run.
        :rtype: list[str]
        """
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--command",
            self.command,
            "--tick-scope",
            self.tick_scope.value,
            "--workers",
            self.workers,
            "--timeout",
            self.timeout,
        ]

        if self.func_takes_flag_ids:
            cmd.extend(["--attack-data-file", self.exported_service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        if self.is_draft:
            cmd.append("--draft")

        return [str(c) for c in cmd]

    def _batch_target_hosts_by_size(self) -> list[list[str]]:
        if (
            self.target_hosts is None
            or self.batching is None
            or self.batching.size is None
        ):
            return []

        return [
            self.target_hosts[i : i + self.batching.size]
            for i in range(0, len(self.target_hosts), self.batching.size)
        ]

    def _batch_target_hosts_by_count(self) -> list[list[str]]:
        if (
            self.target_hosts is None
            or self.batching is None
            or self.batching.count is None
        ):
            return []

        size = len(self.target_hosts) // self.batching.count
        remainder = len(self.target_hosts) % self.batching.count
        batches = [
            self.target_hosts[i * size : (i + 1) * size]
            for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.target_hosts[self.batching.count * size + i])

        return [batch for batch in batches if batch]

    def _export_service_attack_data(self) -> str:
        """
        Exports service scoped attack data to a temporary JSON file.

        :return: Path to the temporary JSON file containing service scoped attack data.
        :rtype: str
        """
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as file:
            json.dump(self.service_attack_data.serialize(), file)
            return file.name

    def _is_first_batch(self, batch_idx: int | None):
        return batch_idx in [None, 0]

    def _is_last_batch(self, batch_idx: int | None):
        return (
            (batch_idx is None)
            or (not self.batched_target_hosts)
            or (batch_idx == len(self.batched_target_hosts) - 1)
        )
