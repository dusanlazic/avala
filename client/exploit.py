import os
import subprocess
from concurrent.futures import Future
from pathlib import Path
from shared.logs import logger
from shared.util import colorize
from datetime import timedelta
from addict import Dict

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"


class Exploit:
    def __init__(self, exploit: dict, flag_ids_future: Future = None):
        exploit = Dict(exploit)

        self.name = exploit.name
        self.targets = exploit.targets or None
        self.skip = exploit.skip or None
        self.service = exploit.service or None
        self.module = exploit.module or exploit.name
        self.command = exploit.command or None
        self.prepare = exploit.prepare or None
        self.cleanup = exploit.cleanup or None
        self.env = exploit.env.to_dict()
        self.delay: timedelta = timedelta(seconds=exploit.delay or 0)
        self.timeout = exploit.timeout or 30

        self._flag_ids_future = flag_ids_future
        self._exploit_data = exploit

    def setup(self):
        if self.service:
            self.flag_ids = self._flag_ids_future.result()
            self.targets = [*self.flag_ids.services[self.service]]

        if self.skip:
            self.targets = [t for t in self.targets if t not in self.skip]

        self.batching = self._exploit_data.batching or Dict()
        if self.batching:
            self.batching.gap = timedelta(seconds=self._exploit_data.batching.gap or 0)

            if self.batching.count:
                self.batches = self._batch_targets_by_count()
            elif self.batching.size:
                self.batches = self._batch_targets_by_size()
        else:
            self.batches = []

    def run(self, batch_idx: int = 0):
        targets = self.batches[batch_idx] if self.batching else self.targets

        if not targets:
            logger.warning(
                f"‚è© Skipped %s due to no targets specified." % colorize(self.name)
            )
            return

        if not self.command:
            cmd = self._build_python_executor_command(targets, batch_idx)
        else:
            cmd = self._build_shell_executor_command(targets, batch_idx)

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})

    def _build_python_executor_command(self, targets: list[str], batch_idx: int = 0):
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--name",
            self.name,
            "--module",
            self.module,
            "--timeout",
            self.timeout,
        ]

        if batch_idx is None:
            cmd.extend(["--prepare", self.prepare, "--cleanup", self.cleanup])
        elif batch_idx == 0:
            cmd.extend(["--prepare", self.prepare])
        elif batch_idx == len(self.batches) - 1:
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = 0):
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--name",
            self.name,
            "--command",
            self.command,
            "--timeout",
            self.timeout,
        ]

        if self.prepare and (batch_idx in [0, None]):
            cmd.extend(["--prepare", self.prepare])
        elif self.cleanup and (batch_idx in [len(self.batches) - 1, None]):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_targets_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_targets_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]
