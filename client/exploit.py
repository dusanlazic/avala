import os
import subprocess
from shared.logs import logger
from datetime import timedelta
from addict import Dict

DIR_PATH = os.path.dirname(os.path.realpath(__file__))
EXECUTOR_PATH = os.path.join(DIR_PATH, "executor.py")


class Exploit:
    def __init__(self, exploit: dict):
        exploit = Dict(exploit)

        self.name = exploit.name
        self.targets = exploit.targets
        self.module = exploit.module or exploit.name
        self.command = exploit.command
        self.prepare = exploit.prepare
        self.cleanup = exploit.cleanup
        self.env = exploit.env.to_dict()
        self.delay: timedelta = timedelta(seconds=exploit.delay or 0)
        self.timeout = exploit.timeout or 30

        if exploit.batching:
            self.batching = exploit.batching
            self.batching.gap = timedelta(seconds=self.batching.gap)

            if self.batching.count:
                self.batching.batches = self._batch_by_count()
            elif self.batching.size:
                self.batching.batches = self._batch_by_size()

    def run(self, batch_idx: int = 0):
        if not self.batching:
            targets = self.targets
        else:
            targets = self.batching.batches[batch_idx]

        cmd = [
            "python",
            EXECUTOR_PATH,
            *targets,
            "--name",
            self.name,
            "--module",
            self.module,
            "--timeout",
            self.timeout,
        ]
        cmd = [str(c) for c in cmd]

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})
        logger.info(f"Exploit {self.name} executed against {len(targets)} targets.")

    def _batch_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]
