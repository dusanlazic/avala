import os
import subprocess
from shared.logs import logger
from shared.util import colorize
from datetime import timedelta
from addict import Dict

DIR_PATH = os.path.dirname(os.path.realpath(__file__))
PYTHON_EXECUTOR_PATH = os.path.join(DIR_PATH, "executor", "python.py")
SHELL_EXECUTOR_PATH = os.path.join(DIR_PATH, "executor", "shell.py")


class Exploit:
    def __init__(self, exploit: dict):
        exploit = Dict(exploit)

        self.name = exploit.name
        self.targets = exploit.targets or None
        self.skip = exploit.skip or None
        self.service = exploit.service or None
        self.module = exploit.module or exploit.name
        self.command = exploit.command or None
        self.prepare = exploit.prepare or None
        self.cleanup = exploit.cleanup or None
        self.env = exploit.env.to_dict()
        self.delay: timedelta = timedelta(seconds=exploit.delay or 0)
        self.timeout = exploit.timeout or 30

        if exploit.batching:
            self.batching = exploit.batching
            self.batching.gap = timedelta(seconds=self.batching.gap)

            if self.batching.count:
                self.batching.batches = self._batch_by_count()
            elif self.batching.size:
                self.batching.batches = self._batch_by_size()
        else:
            self.batching = None

    def run(self, batch_idx: int = 0):
        if not self.batching:
            targets = self.targets
        else:
            targets = self.batching.batches[batch_idx]

        if self.skip:
            targets = [t for t in targets if t not in self.skip]

        if not targets:
            logger.warning(
                f"‚è© Skipped %s due to no targets specified." % colorize(self.name)
            )
            return

        if not self.command:
            cmd = self._build_python_executor_command(targets, batch_idx)
        else:
            cmd = self._build_shell_executor_command(targets, batch_idx)

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})

    def _build_python_executor_command(self, targets: list[str], batch_idx: int = 0):
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--name",
            self.name,
            "--module",
            self.module,
            "--timeout",
            self.timeout,
        ]

        if batch_idx is None:
            cmd.extend(["--prepare", self.prepare, "--cleanup", self.cleanup])
        elif batch_idx == 0:
            cmd.extend(["--prepare", self.prepare])
        elif batch_idx == len(self.batching.batches) - 1:
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = 0):
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--name",
            self.name,
            "--command",
            self.command,
            "--timeout",
            self.timeout,
        ]

        if self.prepare and (batch_idx in [0, None]):
            cmd.extend(["--prepare", self.prepare])
        elif self.cleanup and (batch_idx in [len(self.batching.batches) - 1, None]):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]
