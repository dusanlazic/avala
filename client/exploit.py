from shared.logs import logger
from datetime import timedelta
from addict import Dict


class Exploit:
    def __init__(self, exploit: dict):
        exploit = Dict(exploit)

        self.name = exploit.name
        self.targets = exploit.targets
        self.module = exploit.module
        self.command = exploit.command
        self.prepare = exploit.prepare
        self.cleanup = exploit.cleanup
        self.env = exploit.env.to_dict()
        self.delay: timedelta = timedelta(seconds=exploit.delay or 0)
        self.timeout = exploit.timeout

        if exploit.batching:
            self.batching = exploit.batching
            self.batching.gap = timedelta(seconds=self.batching.gap)

            if self.batching.count:
                self.batching.batches = self._batch_by_count()
            elif self.batching.size:
                self.batching.batches = self._batch_by_size()

    def run(self, batch_idx: int = 0):
        if not self.batching:
            logger.debug(f"Running exploit {self.name} against {self.targets}.")
        else:
            targets = self.batching.batches[batch_idx]
            logger.debug(
                f"Running exploit {self.name} against {targets} (batch {batch_idx + 1}/{len(self.batching.batches)})."
            )

    def _batch_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]
