import os
import json
import tempfile
import subprocess
from concurrent.futures import Future
from pathlib import Path
from .models import (
    ExploitConfig,
    TargetingStrategy,
    UnscopedAttackData,
    ServiceScopedAttackData,
)
from .shared.util import colorize, did_you_mean
from .shared.logs import logger
from .api import APIClient

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"


class Exploit:
    def __init__(
        self,
        config: ExploitConfig,
        client: APIClient,
        attack_data: UnscopedAttackData | Future[UnscopedAttackData],
    ):
        """
        Runnable configured Exploit.

        :param config: Exploit configuration provided by the user through `@exploit` or `@draft` decorators.
        :type config: ExploitConfig
        :param client: Client responsible for communication with the Avala server API and keeping configuration for the game and scheduling.
        :type client: APIClient
        :param attack_data: Either an instance of `UnscopedAttackData` for development mode, or a future object that will return `UnscopedAttackData` for production mode.
        :type attack_data: UnscopedAttackData | Future[UnscopedAttackData]
        :raises ValueError: Exploit configuration is not valid.
        """
        self.client = client

        self.service = config.service
        self.alias = config.alias
        self.targets = config.targets
        self.tick_scope = config.tick_scope
        self.skip = config.skip or [*client.game.team_ip, *client.game.nop_team_ip]
        self.prepare = config.prepare
        self.cleanup = config.cleanup
        self.command = config.command
        self.env = config.env
        self.delay = config.delay
        self.batching = config.batching
        self.workers = config.workers
        self.timeout = config.timeout

        self.func_name = config.meta.name
        self.module = config.meta.module
        self.directory = config.meta.directory
        self.requires_flag_ids = config.meta.arg_count == 2

        self.attack_data = attack_data
        self.service_attack_data: ServiceScopedAttackData
        self.service_attack_data_path: str
        self.is_draft = config.is_draft

        self.batches: list[list[str]] = []

        if not self.requires_flag_ids and self.targets == TargetingStrategy.AUTO:
            raise ValueError(
                f"Cannot use AUTO targeting strategy without flag IDs. Either specify targets manually or add `flag_ids` argument to function <b>{self.func_name}</>."
            )

    def setup(self) -> bool:
        """
        Prepares the exploit by computing attack data, targets, and batching.

        :return: Weather the setup is successful.
        :rtype: boolean
        """
        if self.requires_flag_ids:
            try:
                if isinstance(self.attack_data, Future):
                    self.service_attack_data = self.attack_data.result() / self.service
                elif isinstance(self.attack_data, UnscopedAttackData):
                    self.service_attack_data = self.attack_data / self.service
            except KeyError:
                logger.error(
                    "⚠️ Service <i>%s</> specified for <b>%s</> not found in attack data. "
                    % (
                        self.service,
                        colorize(self.alias),
                    )
                    + did_you_mean(self.service, self.attack_data.get_services())
                )
                return False

            self.service_attack_data_path = self._export_attack_data()

            if self.targets == TargetingStrategy.AUTO:
                self.targets = self.service_attack_data.get_targets()

        if self.targets == TargetingStrategy.OWN_TEAM:
            self.targets = self.client.game.team_ip
        elif self.targets == TargetingStrategy.NOP_TEAM:
            self.targets = self.client.game.nop_team_ip
        else:
            self.targets = [t for t in self.targets if t not in self.skip]

        if self.batching:
            if self.batching.size:
                self.batches = self._batch_targets_by_size()
            elif self.batching.count:
                self.batches = self._batch_targets_by_count()

        return True

    def run(self, batch_idx: int = None):
        """
        Runs the exploit by running appropriate executor in a separate subprocess.

        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        """
        targets = self.batches[batch_idx] if self.batching else self.targets

        if not targets:
            logger.warning(
                f"⏩ Skipped %s due to no targets specified." % colorize(self.alias)
            )
            return

        if self.command:
            # For shell exploits: To prevent zombie processes after a timeout,
            # the exploit processes must be terminated within the executor. Exit
            # codes are used to differentiate between timeouts and other errors.

            cmd = self._build_shell_executor_command(targets, batch_idx)
            try:
                subprocess.run(
                    cmd,
                    text=True,
                    env={**self.env, **os.environ},
                    check=True,
                )
            except subprocess.CalledProcessError as e:
                if e.returncode == 2:
                    logger.error(
                        "Exploit <b>%s</> exited because it has timed out."
                        % colorize(self.alias)
                    )
                else:
                    logger.error(
                        "Exploit <b>%s</> exited with non-zero exit code %d."
                        % (colorize(self.alias), e.returncode)
                    )
        else:
            # For Python exploits: Timeouts are managed by terminating the executor
            # process itself, which will terminate all exploit theads. This is done
            # via the timeout parameter in subprocess.run.

            cmd = self._build_python_executor_command(targets, batch_idx)
            try:
                subprocess.run(
                    cmd,
                    text=True,
                    env={**self.env, **os.environ},
                    timeout=self.timeout,
                )
            except subprocess.TimeoutExpired:
                logger.error(
                    "Exploit <b>%s</> exited because it has timed out."
                    % colorize(self.alias)
                )

        if self.requires_flag_ids and self._is_last_batch(batch_idx):
            try:
                os.unlink(self.service_attack_data_path)
            except FileNotFoundError:
                pass

    def _build_python_executor_command(
        self,
        targets: list[str],
        batch_idx: int = None,
    ) -> list[str]:
        """
        Builds a command to run the exploit using the Python executor.

        :param targets: List of IP addresses or hostnames of the targets.
        :type targets: list[str]
        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        :return: Command to run.
        :rtype: list[str]
        """
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--func-name",
            self.func_name,
            "--module",
            self.module,
            "--directory",
            self.directory,
            "--tick-scope",
            self.tick_scope.value,
            "--workers",
            self.workers,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--attack-data-file", self.service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        if self.is_draft:
            cmd.append("--draft")

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = None):
        """
        Builds a command to run the exploit using the shell executor.

        :param targets: List of IP addresses or hostnames of the targets.
        :type targets: list[str]
        :param batch_idx: Index of the batch if batching is enabled, defaults to None
        :type batch_idx: int, optional
        :return: Command to run.
        :rtype: list[str]
        """
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--command",
            self.command,
            "--tick-scope",
            self.tick_scope.value,
            "--workers",
            self.workers,
            "--timeout",
            self.timeout,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--attack-data-file", self.service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_targets_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_targets_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]

    def _export_attack_data(self) -> str:
        """
        Exports service scoped attack data to a temporary JSON file.

        :return: Path to the temporary JSON file containing service scoped attack data.
        :rtype: str
        """
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as file:
            json.dump(self.service_attack_data.serialize(), file)
            return file.name

    def _is_first_batch(self, batch_idx):
        return batch_idx in [None, 0]

    def _is_last_batch(self, batch_idx):
        return (
            (batch_idx is None)
            or (not self.batches)
            or (batch_idx == len(self.batches) - 1)
        )
