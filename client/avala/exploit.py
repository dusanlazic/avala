import os
import json
import tempfile
import subprocess
from concurrent.futures import Future
from pathlib import Path
from .models import BatchBySize, BatchByCount, ExploitConfig, TargetingStrategy
from .shared.util import colorize
from .shared.logs import logger

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"

AUTO = TargetingStrategy.AUTO


class Exploit:
    def __init__(
        self,
        config: ExploitConfig,
        flag_ids: dict = None,
        flag_ids_future: Future = None,
    ):
        self.service = config.service
        self.alias = config.alias
        self.targets = config.targets
        self.skip = config.skip
        self.prepare = config.prepare
        self.cleanup = config.cleanup
        self.command = config.command
        self.env = config.env
        self.delay = config.delay
        self.batching = config.batching
        self.timeout = config.timeout

        self.func_name = config.meta.name
        self.module = config.meta.module
        self.directory = config.meta.directory
        self.requires_flag_ids = config.meta.arg_count == 2

        self.flag_ids_future = flag_ids_future
        self.flag_ids_fetched = flag_ids
        self.flag_ids_filepath: str

        self.batches: list[list[str]] = []

        if not self.requires_flag_ids and self.targets == AUTO:
            raise ValueError(
                f"Cannot use AUTO targeting strategy without flag IDs. Either specify targets manually or add another argument to {self.module}.{self.func_name} in {self.directory}."
            )

    def setup(self):
        if self.requires_flag_ids:
            if self.flag_ids_future:
                self.flag_ids = self.flag_ids_future.result()["services"][self.service]
            elif self.flag_ids_fetched:
                self.flag_ids = self.flag_ids_fetched["services"][self.service]

            self.flag_ids_filepath = self._export_flag_ids()
            self.targets = [*self.flag_ids] if self.targets == AUTO else self.targets

        if self.skip:
            self.targets = [t for t in self.targets if t not in self.skip]

        if self.batching:
            if isinstance(self.batching, BatchBySize):
                self.batches = self._batch_targets_by_size()
            elif isinstance(self.batching, BatchByCount):
                self.batches = self._batch_targets_by_count()

    def run(self, batch_idx: int = None):
        targets = self.batches[batch_idx] if self.batching else self.targets

        if not targets:
            logger.warning(
                f"‚è© Skipped %s due to no targets specified." % colorize(self.alias)
            )
            return

        if self.command:
            cmd = self._build_shell_executor_command(targets, batch_idx)
        else:
            cmd = self._build_python_executor_command(targets, batch_idx)

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})

        if self.requires_flag_ids and self._is_last_batch(batch_idx):
            try:
                os.unlink(self.flag_ids_filepath)
            except FileNotFoundError:
                pass

    def _build_python_executor_command(self, targets: list[str], batch_idx: int = None):
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--func-name",
            self.func_name,
            "--module",
            self.module,
            "--directory",
            self.directory,
            "--timeout",
            self.timeout,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--flag-ids-file", self.flag_ids_filepath])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = None):
        # TODO: Adapt to decorator API
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--command",
            self.command,
            "--timeout",
            self.timeout,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--flag-ids-file", self.flag_ids_filepath])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_targets_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_targets_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]

    def _export_flag_ids(self):
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as file:
            json.dump(self.flag_ids, file)
            return file.name

    def _is_first_batch(self, batch_idx):
        return batch_idx in [None, 0]

    def _is_last_batch(self, batch_idx):
        return (
            (batch_idx is None)
            or (not self.batches)
            or (batch_idx == len(self.batches) - 1)
        )
