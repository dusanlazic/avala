import os
import json
import tempfile
import subprocess
from concurrent.futures import Future
from pathlib import Path
from datetime import timedelta
from addict import Dict
from .shared.util import colorize
from .shared.logs import logger

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"


class Exploit:
    def __init__(self, config: dict, flag_ids_future: Future = None):
        config = Dict(config)

        self.alias = config.alias or config.meta.module + "." + config.meta.name
        self.targets = config.targets or None
        self.skip = config.skip or None
        self.service = config.service
        self.prepare = config.prepare or None
        self.cleanup = config.cleanup or None
        self.env = config.env.to_dict() if config.env else {}
        self.delay: timedelta = timedelta(seconds=config.delay or 0)
        self.timeout = config.timeout or 30
        self.batching = config.batching

        self.func_name = config.meta.name
        self.module = config.meta.module
        self.directory = config.meta.directory

        self._flag_ids_future = flag_ids_future

    def setup(self):
        if not self.targets:
            self.flag_ids: dict = self._flag_ids_future.result().services[self.service]
            self.flag_ids_filepath: str = self._export_flag_ids()
            self.targets: list[str] = [*self.flag_ids]

        if self.skip:
            self.targets = [t for t in self.targets if t not in self.skip]

        if self.batching:
            self.batching.gap = timedelta(seconds=self.batching.gap or 0)
            if self.batching.size:
                self.batches = self._batch_targets_by_size()
            elif self.batching.count:
                self.batches = self._batch_targets_by_count()
        else:
            self.batches = []

    def run(self, batch_idx: int = 0):
        targets = self.batches[batch_idx] if self.batching else self.targets

        if not targets:
            logger.warning(
                f"‚è© Skipped %s due to no targets specified." % colorize(self.alias)
            )
            return

        # TODO: Adapt to decorator API
        # if not self.command:
        #   cmd = self._build_python_executor_command(targets, batch_idx)
        # else:
        #   cmd = self._build_shell_executor_command(targets, batch_idx)
        cmd = self._build_python_executor_command(targets, batch_idx)

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})

        if not self.batches or batch_idx == len(self.batches) - 1:
            try:
                os.unlink(self.flag_ids_filepath)
            except FileNotFoundError:
                pass

    def _build_python_executor_command(self, targets: list[str], batch_idx: int = None):
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--func-name",
            self.func_name,
            "--module",
            self.module,
            "--directory",
            self.directory,
            "--timeout",
            self.timeout,
        ]

        if self.service:
            cmd.extend(["--flag-ids-file", self.flag_ids_filepath])

        if not self.batches:
            cmd.extend(["--prepare", self.prepare, "--cleanup", self.cleanup])
        elif batch_idx == 0:
            cmd.extend(["--prepare", self.prepare])
        elif batch_idx == len(self.batches) - 1:
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = 0):
        # TODO: Adapt to decorator API
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--name",
            self.alias,
            "--command",
            self.command,
            "--timeout",
            self.timeout,
        ]

        if self.service:
            cmd.extend(["--flag-ids-file", self.flag_ids_filepath])

        if self.prepare and (batch_idx in [0, None]):
            cmd.extend(["--prepare", self.prepare])
        elif self.cleanup and (batch_idx in [len(self.batches) - 1, None]):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_targets_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_targets_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]

    def _export_flag_ids(self):
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as file:
            json.dump(self.flag_ids, file)
            return file.name
