import os
import json
import tempfile
import subprocess
from concurrent.futures import Future
from pathlib import Path
from .models import (
    ExploitConfig,
    TargetingStrategy,
    UnscopedAttackData,
    ServiceScopedAttackData,
)
from .shared.util import colorize
from .shared.logs import logger

DIR_PATH = Path(__file__).resolve().parent
PYTHON_EXECUTOR_PATH = DIR_PATH / "executor" / "python.py"
SHELL_EXECUTOR_PATH = DIR_PATH / "executor" / "shell.py"

AUTO = TargetingStrategy.AUTO


class Exploit:
    def __init__(
        self,
        config: ExploitConfig,
        attack_data: UnscopedAttackData | Future[UnscopedAttackData],
    ):
        self.service = config.service
        self.alias = config.alias
        self.targets = config.targets
        self.tick_scope = config.tick_scope
        self.skip = config.skip
        self.prepare = config.prepare
        self.cleanup = config.cleanup
        self.command = config.command
        self.env = config.env
        self.delay = config.delay
        self.batching = config.batching
        self.timeout = config.timeout

        self.func_name = config.meta.name
        self.module = config.meta.module
        self.directory = config.meta.directory
        self.requires_flag_ids = config.meta.arg_count == 2

        self.attack_data = attack_data
        self.service_attack_data: ServiceScopedAttackData
        self.service_attack_data_path: str

        self.batches: list[list[str]] = []

        if not self.requires_flag_ids and self.targets == AUTO:
            raise ValueError(
                f"Cannot use AUTO targeting strategy without flag IDs. Either specify targets manually or add another argument to {self.module}.{self.func_name} in {self.directory}."
            )

    def setup(self):
        if self.requires_flag_ids:
            if isinstance(self.attack_data, Future):
                self.service_attack_data = self.attack_data.result() / self.service
            elif isinstance(self.attack_data, UnscopedAttackData):
                self.service_attack_data = self.attack_data / self.service

            self.service_attack_data_path = self._export_attack_data()

            self.targets = (
                self.service_attack_data.get_targets()
                if self.targets == AUTO
                else self.targets
            )

        if self.skip:
            self.targets = [t for t in self.targets if t not in self.skip]

        if self.batching:
            if self.batching.size:
                self.batches = self._batch_targets_by_size()
            elif self.batching.count:
                self.batches = self._batch_targets_by_count()

    def run(self, batch_idx: int = None):
        targets = self.batches[batch_idx] if self.batching else self.targets

        if not targets:
            logger.warning(
                f"‚è© Skipped %s due to no targets specified." % colorize(self.alias)
            )
            return

        if self.command:
            cmd = self._build_shell_executor_command(targets, batch_idx)
        else:
            cmd = self._build_python_executor_command(targets, batch_idx)

        subprocess.run(cmd, text=True, env={**self.env, **os.environ})

        if self.requires_flag_ids and self._is_last_batch(batch_idx):
            try:
                os.unlink(self.service_attack_data_path)
            except FileNotFoundError:
                pass

    def _build_python_executor_command(self, targets: list[str], batch_idx: int = None):
        cmd = [
            "python",
            PYTHON_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--func-name",
            self.func_name,
            "--module",
            self.module,
            "--directory",
            self.directory,
            "--timeout",
            self.timeout,
            "--tick-scope",
            self.tick_scope.value,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--attack-data-file", self.service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd if c is not None]
        return cmd

    def _build_shell_executor_command(self, targets: list[str], batch_idx: int = None):
        # TODO: Adapt to decorator API
        cmd = [
            "python",
            SHELL_EXECUTOR_PATH,
            *targets,
            "--alias",
            self.alias,
            "--command",
            self.command,
            "--timeout",
            self.timeout,
        ]

        if self.requires_flag_ids:
            cmd.extend(["--attack-data-file", self.service_attack_data_path])

        if self.prepare and self._is_first_batch(batch_idx):
            cmd.extend(["--prepare", self.prepare])
        if self.cleanup and self._is_last_batch(batch_idx):
            cmd.extend(["--cleanup", self.cleanup])

        cmd = [str(c) for c in cmd]
        return cmd

    def _batch_targets_by_size(self):
        return [
            self.targets[i : i + self.batching.size]
            for i in range(0, len(self.targets), self.batching.size)
        ]

    def _batch_targets_by_count(self):
        size = len(self.targets) // self.batching.count
        remainder = len(self.targets) % self.batching.count
        batches = [
            self.targets[i * size : (i + 1) * size] for i in range(self.batching.count)
        ]
        for i in range(remainder):
            batches[i].append(self.targets[self.batching.count * size + i])

        return [batch for batch in batches if batch]

    def _export_attack_data(self):
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as file:
            json.dump(self.service_attack_data.serialize(), file)
            return file.name

    def _is_first_batch(self, batch_idx):
        return batch_idx in [None, 0]

    def _is_last_batch(self, batch_idx):
        return (
            (batch_idx is None)
            or (not self.batches)
            or (batch_idx == len(self.batches) - 1)
        )
